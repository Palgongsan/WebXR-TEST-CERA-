<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CERA WebAR</title>
    
    <!-- Three.js ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .container {
            max-width: 400px;
            width: 100%;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            font-size: 1.1rem;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .ar-button {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E);
            color: white;
            border: none;
            padding: 18px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.4);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .ar-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 25px rgba(255, 107, 107, 0.6);
        }

        .ar-button:active {
            transform: translateY(0px);
        }

        .info {
            margin-top: 25px;
            font-size: 0.9rem;
            opacity: 0.8;
            line-height: 1.5;
        }

        .loading {
            display: none;
            margin-top: 20px;
            font-size: 1rem;
        }

        .controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 25px;
            z-index: 1000;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CERA</h1>
        <p class="subtitle">ì¦ê°•í˜„ì‹¤ë¡œ ì²´í—˜í•´ë³´ì„¸ìš”</p>
        
        <button class="ar-button" onclick="activateXR()">AR ì²´í—˜ ì‹œì‘</button>
        
        <div class="loading" id="loading">
            ëª¨ë¸ì„ ë¡œë”©ì¤‘ì…ë‹ˆë‹¤...
        </div>
        
        <div class="info">
            <p>ğŸ“± Android ë””ë°”ì´ìŠ¤ì—ì„œ Chrome ë¸Œë¼ìš°ì € ì‚¬ìš© ê¶Œì¥</p>
            <p>ğŸ¯ í‰í‰í•œ ë°”ë‹¥ì´ë‚˜ í…Œì´ë¸”ì„ ì°¾ì•„ ëª¨ë¸ì„ ë°°ì¹˜í•˜ì„¸ìš”</p>
            <p>âœ‹ í™”ë©´ì„ íƒ­í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ì„ ì œì–´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
        </div>
    </div>

    <!-- AR ì œì–´ ë²„íŠ¼ë“¤ (AR ëª¨ë“œì—ì„œë§Œ í‘œì‹œ) -->
    <div class="controls" id="arControls">
        <button class="control-button" onclick="playAnimation()">ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ</button>
        <button class="control-button" onclick="resetModel()">ëª¨ë¸ ë¦¬ì…‹</button>
    </div>

    <script>
        // ===========================================
        // ğŸ”§ ì£¼ìš” ì„¤ì • íŒŒë¼ë¯¸í„°ë“¤ (ì´ ë¶€ë¶„ì„ ìˆ˜ì •í•˜ì„¸ìš”)
        // ===========================================
        
        const CONFIG = {
            // ëª¨ë¸ íŒŒì¼ ê²½ë¡œ (GLB íŒŒì¼ëª…ì„ ì—¬ê¸°ì„œ ìˆ˜ì •)
            MODEL_PATH: './CERA_V11.glb',
            
            // ì• ë‹ˆë©”ì´ì…˜ ì´ë¦„ë“¤ (GLB íŒŒì¼ì˜ ì• ë‹ˆë©”ì´ì…˜ ì´ë¦„ê³¼ ì •í™•íˆ ì¼ì¹˜í•´ì•¼ í•¨)
            ANIMATIONS: {
                CHAIR_MODE: 'CERA_V11_ChairMode(1)_Baked',      // ê¸°ë³¸ ìì„¸ (1í”„ë ˆì„)
                CYLINDER_ACTION: 'CERA_V11_CylinderAction(240)_Baked', // ë©”ì¸ ì• ë‹ˆë©”ì´ì…˜ (240í”„ë ˆì„)
                STRETCH: 'CERA_V11_Stretch(1)_Baked'           // ë ìì„¸ (1í”„ë ˆì„)
            },
            
            // ëª¨ë¸ í¬ê¸° ë°°ìœ¨ (1.0 = ì›ë³¸ í¬ê¸°, 0.5 = ì ˆë°˜ í¬ê¸°)
            MODEL_SCALE: 1.0,
            
            // ëª¨ë¸ì˜ ê¸°ë³¸ íšŒì „ (Yì¶• ê¸°ì¤€, ë¼ë””ì•ˆ ë‹¨ìœ„)
            MODEL_ROTATION_Y: 0,
            
            // ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ ì†ë„ (1.0 = ì •ìƒ ì†ë„, 0.5 = ì ˆë°˜ ì†ë„)
            ANIMATION_SPEED: 1.0,
            
            // Hit-test ê²°ê³¼ í‘œì‹œìš© reticle ìƒ‰ìƒ
            RETICLE_COLOR: 0x00ff00,  // ë…¹ìƒ‰ (0xff0000: ë¹¨ê°•, 0x0000ff: íŒŒë‘)
            
            // ì¡°ëª… ì„¤ì •
            LIGHT_INTENSITY: 0.8,    // ì¡°ëª… ê°•ë„ (0.0 ~ 1.0)
            LIGHT_COLOR: 0xffffff,   // ì¡°ëª… ìƒ‰ìƒ (í°ìƒ‰)
        };
        
        // ===========================================
        // ğŸ® ì „ì—­ ë³€ìˆ˜ë“¤
        // ===========================================
        let xrSession = null;
        let xrReferenceSpace = null;
        let xrHitTestSource = null;
        let renderer = null;
        let scene = null;
        let camera = null;
        let ceraModel = null;          // CERA 3D ëª¨ë¸
        let animationMixer = null;     // ì• ë‹ˆë©”ì´ì…˜ ë¯¹ì„œ
        let currentAnimations = {};    // í˜„ì¬ ì¬ìƒì¤‘ì¸ ì• ë‹ˆë©”ì´ì…˜ë“¤
        let currentState = 'CHAIR_MODE'; // í˜„ì¬ ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ
        let reticle = null;            // Hit-test ê²°ê³¼ í‘œì‹œìš© reticle
        let modelPlaced = false;       // ëª¨ë¸ì´ ë°°ì¹˜ë˜ì—ˆëŠ”ì§€ ì—¬ë¶€
        
        // ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ ê´€ë¦¬
        const animationStates = {
            CHAIR_MODE: 'CHAIR_MODE',
            CYLINDER_ACTION: 'CYLINDER_ACTION', 
            STRETCH: 'STRETCH'
        };

        // ===========================================
        // ğŸš€ WebXR ì„¸ì…˜ ì‹œì‘ í•¨ìˆ˜
        // ===========================================
        async function activateXR() {
            try {
                // ë¡œë”© í‘œì‹œ
                document.getElementById('loading').style.display = 'block';
                
                // WebXR ì§€ì› í™•ì¸
                if (!navigator.xr) {
                    alert('ì´ ë¸Œë¼ìš°ì €ëŠ” WebXRì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                    return;
                }

                // AR ì„¸ì…˜ ì§€ì› í™•ì¸
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    alert('ì´ ë””ë°”ì´ìŠ¤ëŠ” ARì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                    return;
                }

                // WebGL ì»¨í…ìŠ¤íŠ¸ ìƒì„±
                const canvas = document.createElement('canvas');
                document.body.appendChild(canvas);
                const gl = canvas.getContext('webgl', { xrCompatible: true });

                if (!gl) {
                    alert('WebGLì„ ì´ˆê¸°í™”í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }

                // Three.js ë Œë”ëŸ¬ ì„¤ì •
                renderer = new THREE.WebGLRenderer({
                    alpha: true,
                    preserveDrawingBuffer: true,
                    canvas: canvas,
                    context: gl
                });
                renderer.autoClear = false;
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // ì”¬ ìƒì„± ë° ì¡°ëª… ì„¤ì •
                scene = new THREE.Scene();
                
                // í™˜ê²½ê´‘ ì¶”ê°€
                const ambientLight = new THREE.AmbientLight(CONFIG.LIGHT_COLOR, 0.4);
                scene.add(ambientLight);
                
                // ì§ì§„ê´‘ ì¶”ê°€
                const directionalLight = new THREE.DirectionalLight(CONFIG.LIGHT_COLOR, CONFIG.LIGHT_INTENSITY);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                // ì¹´ë©”ë¼ ì„¤ì •
                camera = new THREE.PerspectiveCamera();
                camera.matrixAutoUpdate = false;

                // CERA ëª¨ë¸ ë¡œë“œ
                await loadCeraModel();

                // Reticle (íƒ€ê²Ÿ í‘œì‹œê¸°) ìƒì„±
                createReticle();

                // AR ì„¸ì…˜ ì‹œì‘
                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test']
                });

                xrSession.updateRenderState({
                    baseLayer: new XRWebGLLayer(xrSession, gl)
                });

                // ì°¸ì¡° ê³µê°„ ì„¤ì •
                xrReferenceSpace = await xrSession.requestReferenceSpace('local');

                // Hit-test ì†ŒìŠ¤ ìƒì„±
                const viewerSpace = await xrSession.requestReferenceSpace('viewer');
                xrHitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

                // í„°ì¹˜ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ëª¨ë¸ ë°°ì¹˜ ë° ì• ë‹ˆë©”ì´ì…˜ ì œì–´)
                xrSession.addEventListener('select', onSelect);

                // AR ë Œë”ë§ ë£¨í”„ ì‹œì‘
                xrSession.requestAnimationFrame(onXRFrame);

                // UI ì—…ë°ì´íŠ¸
                document.querySelector('.container').style.display = 'none';
                document.getElementById('arControls').style.display = 'block';
                
            } catch (error) {
                console.error('AR ì„¸ì…˜ ì‹œì‘ ì‹¤íŒ¨:', error);
                alert('AR ì„¸ì…˜ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + error.message);
                document.getElementById('loading').style.display = 'none';
            }
        }

        // ===========================================
        // ğŸ“¦ CERA ëª¨ë¸ ë¡œë”© í•¨ìˆ˜
        // ===========================================
        async function loadCeraModel() {
            return new Promise((resolve, reject) => {
                const loader = new THREE.GLTFLoader();
                
                loader.load(
                    CONFIG.MODEL_PATH,
                    (gltf) => {
                        ceraModel = gltf.scene;
                        
                        // ëª¨ë¸ í¬ê¸° ë° íšŒì „ ì„¤ì •
                        ceraModel.scale.setScalar(CONFIG.MODEL_SCALE);
                        ceraModel.rotation.y = CONFIG.MODEL_ROTATION_Y;
                        
                        // ê·¸ë¦¼ì ì„¤ì •
                        ceraModel.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        // ì• ë‹ˆë©”ì´ì…˜ ë¯¹ì„œ ì„¤ì •
                        if (gltf.animations && gltf.animations.length > 0) {
                            animationMixer = new THREE.AnimationMixer(ceraModel);
                            
                            // ê° ì• ë‹ˆë©”ì´ì…˜ì„ ì´ë¦„ìœ¼ë¡œ ì €ì¥
                            gltf.animations.forEach(clip => {
                                const action = animationMixer.clipAction(clip);
                                currentAnimations[clip.name] = action;
                                console.log('ë¡œë“œëœ ì• ë‹ˆë©”ì´ì…˜:', clip.name);
                            });

                            // ê¸°ë³¸ ì• ë‹ˆë©”ì´ì…˜(Chair Mode) ì„¤ì • ë° ì¬ìƒ
                            if (currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE]) {
                                const chairAction = currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE];
                                chairAction.setLoop(THREE.LoopOnce);
                                chairAction.clampWhenFinished = true;
                                chairAction.play();
                                currentState = animationStates.CHAIR_MODE;
                                console.log('ê¸°ë³¸ ì• ë‹ˆë©”ì´ì…˜(Chair Mode) ì¬ìƒ');
                            }
                        }

                        console.log('CERA ëª¨ë¸ ë¡œë”© ì™„ë£Œ');
                        resolve();
                    },
                    (progress) => {
                        console.log('ë¡œë”© ì§„í–‰ë¥ :', (progress.loaded / progress.total * 100) + '%');
                    },
                    (error) => {
                        console.error('ëª¨ë¸ ë¡œë”© ì‹¤íŒ¨:', error);
                        reject(error);
                    }
                );
            });
        }

        // ===========================================
        // ğŸ¯ Reticle (íƒ€ê²Ÿ í‘œì‹œê¸°) ìƒì„±
        // ===========================================
        function createReticle() {
            const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ 
                color: CONFIG.RETICLE_COLOR,
                transparent: true,
                opacity: 0.8
            });
            
            reticle = new THREE.Mesh(geometry, material);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);
        }

        // ===========================================
        // ğŸ¬ ì• ë‹ˆë©”ì´ì…˜ ì œì–´ í•¨ìˆ˜ë“¤
        // ===========================================
        
        // ì• ë‹ˆë©”ì´ì…˜ ì „í™˜ í•¨ìˆ˜
        function transitionToAnimation(targetState, reverse = false) {
            if (!animationMixer || !currentAnimations) return;

            console.log(`ì• ë‹ˆë©”ì´ì…˜ ì „í™˜: ${currentState} -> ${targetState} (ì—­ì¬ìƒ: ${reverse})`);

            // í˜„ì¬ ì¬ìƒì¤‘ì¸ ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì§€
            Object.values(currentAnimations).forEach(action => {
                action.stop();
            });

            let targetAction;
            
            switch (targetState) {
                case animationStates.CHAIR_MODE:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = CONFIG.ANIMATION_SPEED;
                        targetAction.play();
                    }
                    break;

                case animationStates.CYLINDER_ACTION:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.CYLINDER_ACTION];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = reverse ? -CONFIG.ANIMATION_SPEED : CONFIG.ANIMATION_SPEED;
                        
                        if (reverse) {
                            // ì—­ì¬ìƒì„ ìœ„í•´ ë ì§€ì ì—ì„œ ì‹œì‘
                            targetAction.time = targetAction.getClip().duration;
                        }
                        
                        targetAction.play();
                        
                        // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ë‹¤ìŒ ìƒíƒœë¡œ ì „í™˜
                        const mixer = animationMixer;
                        const onAnimationComplete = () => {
                            mixer.removeEventListener('finished', onAnimationComplete);
                            if (reverse) {
                                transitionToAnimation(animationStates.CHAIR_MODE);
                            } else {
                                transitionToAnimation(animationStates.STRETCH);
                            }
                        };
                        mixer.addEventListener('finished', onAnimationComplete);
                    }
                    break;

                case animationStates.STRETCH:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.STRETCH];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = CONFIG.ANIMATION_SPEED;
                        targetAction.play();
                    }
                    break;
            }

            currentState = targetState;
        }

        // ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ (ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥)
        function playAnimation() {
            if (!modelPlaced) {
                alert('ë¨¼ì € ëª¨ë¸ì„ ë°°ì¹˜í•´ì£¼ì„¸ìš”.');
                return;
            }

            switch (currentState) {
                case animationStates.CHAIR_MODE:
                    // Chair -> Cylinder -> Stretch ìˆœì„œë¡œ ì¬ìƒ
                    transitionToAnimation(animationStates.CYLINDER_ACTION, false);
                    break;
                    
                case animationStates.STRETCH:
                    // Stretch -> Cylinder(ì—­ì¬ìƒ) -> Chair ìˆœì„œë¡œ ì¬ìƒ
                    transitionToAnimation(animationStates.CYLINDER_ACTION, true);
                    break;
                    
                case animationStates.CYLINDER_ACTION:
                    // ì´ë¯¸ ì¬ìƒì¤‘ì´ë©´ ë¬´ì‹œ
                    console.log('ì• ë‹ˆë©”ì´ì…˜ì´ ì´ë¯¸ ì¬ìƒì¤‘ì…ë‹ˆë‹¤.');
                    break;
            }
        }

        // ëª¨ë¸ ë¦¬ì…‹ í•¨ìˆ˜
        function resetModel() {
            if (!modelPlaced) return;
            
            transitionToAnimation(animationStates.CHAIR_MODE);
            console.log('ëª¨ë¸ì´ ê¸°ë³¸ ìƒíƒœë¡œ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤.');
        }

        // ===========================================
        // ğŸ‘† í„°ì¹˜/ì„ íƒ ì´ë²¤íŠ¸ ì²˜ë¦¬
        // ===========================================
        function onSelect(event) {
            if (!modelPlaced && reticle.visible) {
                // ëª¨ë¸ì´ ì•„ì§ ë°°ì¹˜ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë°°ì¹˜
                const reticlePosition = new THREE.Vector3();
                reticle.getWorldPosition(reticlePosition);
                
                ceraModel.position.copy(reticlePosition);
                scene.add(ceraModel);
                
                modelPlaced = true;
                reticle.visible = false;
                
                console.log('CERA ëª¨ë¸ì´ ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } else if (modelPlaced) {
                // ëª¨ë¸ì´ ì´ë¯¸ ë°°ì¹˜ë˜ì—ˆë‹¤ë©´ ì• ë‹ˆë©”ì´ì…˜ ì œì–´
                playAnimation();
            }
        }

        // ===========================================
        // ğŸ¨ XR ë Œë”ë§ ë£¨í”„
        // ===========================================
        function onXRFrame(time, frame) {
            xrSession.requestAnimationFrame(onXRFrame);

            const referenceSpace = xrReferenceSpace;
            const pose = frame.getViewerPose(referenceSpace);

            if (pose) {
                const view = pose.views[0];
                const viewport = xrSession.renderState.baseLayer.getViewport(view);
                
                renderer.setSize(viewport.width, viewport.height);

                // ì¹´ë©”ë¼ ë§¤íŠ¸ë¦­ìŠ¤ ì—…ë°ì´íŠ¸
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.updateMatrixWorld(true);

                // Hit-test ê²°ê³¼ ì²˜ë¦¬ (ëª¨ë¸ì´ ì•„ì§ ë°°ì¹˜ë˜ì§€ ì•Šì•˜ì„ ë•Œë§Œ)
                if (xrHitTestSource && !modelPlaced) {
                    const hitTestResults = frame.getHitTestResults(xrHitTestSource);
                    
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const hitPose = hit.getPose(referenceSpace);
                        
                        reticle.visible = true;
                        reticle.matrix.fromArray(hitPose.transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }

                // ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
                if (animationMixer) {
                    animationMixer.update(0.016); // ì•½ 60fps
                }

                // WebXR í”„ë ˆì„ë²„í¼ì— ë°”ì¸ë”©
                const glLayer = xrSession.renderState.baseLayer;
                renderer.getContext().bindFramebuffer(renderer.getContext().FRAMEBUFFER, glLayer.framebuffer);

                // ì”¬ ë Œë”ë§
                renderer.render(scene, camera);
            }
        }

        // ===========================================
        // ğŸ› ï¸ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        // ===========================================
        
        // ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬
        function checkCompatibility() {
            if (!navigator.xr) {
                document.querySelector('.ar-button').disabled = true;
                document.querySelector('.ar-button').textContent = 'WebXR ë¯¸ì§€ì›';
                document.querySelector('.info').innerHTML = '<p style="color: #ff6b6b;">âŒ ì´ ë¸Œë¼ìš°ì €ëŠ” WebXRì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</p>';
                return false;
            }
            return true;
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ í˜¸í™˜ì„± ì²´í¬
        window.addEventListener('load', () => {
            checkCompatibility();
        });

        // ì„¸ì…˜ ì¢…ë£Œ ì²˜ë¦¬
        function endXRSession() {
            if (xrSession) {
                xrSession.end();
                xrSession = null;
                
                // UI ë¦¬ì…‹
                document.querySelector('.container').style.display = 'block';
                document.getElementById('arControls').style.display = 'none';
                
                // ë³€ìˆ˜ ì´ˆê¸°í™”
                modelPlaced = false;
                currentState = animationStates.CHAIR_MODE;
                
                // Canvas ì œê±°
                const canvas = document.querySelector('canvas');
                if (canvas) {
                    canvas.remove();
                }
                
                console.log('AR ì„¸ì…˜ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        }

        // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ì„¸ì…˜ ì •ë¦¬
        window.addEventListener('beforeunload', endXRSession);
        
    </script>
</body>
</html>