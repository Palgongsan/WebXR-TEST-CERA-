<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CERA WebAR</title>
    
    <!-- Three.js 라이브러리 -->
    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Draco 압축 지원을 위한 로더 -->
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/DRACOLoader.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: #000000;
            color: white;
            text-align: center;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .ar-button {
            background: #333333;
            color: white;
            border: 2px solid #666666;
            padding: 20px 50px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .ar-button:hover {
            background: #555555;
            border-color: #888888;
        }

        .ar-button:active {
            background: #222222;
        }

        .ar-button:disabled {
            background: #111111;
            color: #555555;
            cursor: not-allowed;
            border-color: #333333;
        }

        .loading {
            display: none;
            margin-top: 20px;
            font-size: 1rem;
        }

        .controls {
            display: none;
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            z-index: 1000;
            border: 1px solid #333333;
        }

        .control-button {
            background: #333333;
            color: white;
            border: 1px solid #666666;
            padding: 12px 20px;
            margin: 0 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s ease;
        }

        .control-button:hover {
            background: #555555;
        }

        .control-button:active {
            background: #222222;
        }

        .debug {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-width: 300px;
            z-index: 1001;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <button class="ar-button" id="arButton" onclick="activateXR()">AR 체험 시작</button>
    
    <div class="loading" id="loading">
        모델을 로딩중입니다...
    </div>
    
    <!-- 디버그 정보 표시 -->
    <div class="debug" id="debug">
        상태: 대기중
    </div>

    <!-- AR 제어 버튼들 -->
    <div class="controls" id="arControls">
        <button class="control-button" onclick="playAnimation()">애니메이션 재생</button>
        <button class="control-button" onclick="resetModel()">모델 리셋</button>
        <button class="control-button" onclick="endXRSession()">AR 종료</button>
    </div>

    <script>
        // ===========================================
        // 🔧 주요 설정 파라미터들 (이 부분을 수정하세요)
        // ===========================================
        
        const CONFIG = {
            // 모델 파일 경로 (GLB 파일명을 여기서 수정)
            MODEL_PATH: './CERA_V11.glb',
            
            // Draco 디코더 경로 (CDN에서 자동으로 로드됨)
            DRACO_DECODER_PATH: 'https://unpkg.com/three@0.126.0/examples/js/libs/draco/',
            
            // 애니메이션 이름들 (GLB 파일의 애니메이션 이름과 정확히 일치해야 함)
            ANIMATIONS: {
                CHAIR_MODE: 'CERA_V11_ChairMode(1)_Baked',      // 기본 자세 (1프레임)
                CYLINDER_ACTION: 'CERA_V11_CylinderAction(240)_Baked', // 메인 애니메이션 (240프레임)
                STRETCH: 'CERA_V11_Stretch(1)_Baked'           // 끝 자세 (1프레임)
            },
            
            // 모델 크기 배율 (1.0 = 원본 크기, 0.5 = 절반 크기)
            MODEL_SCALE: 1.0,
            
            // 모델의 기본 회전 (Y축 기준, 라디안 단위)
            MODEL_ROTATION_Y: 0,
            
            // 애니메이션 재생 속도 (1.0 = 정상 속도, 0.5 = 절반 속도)
            ANIMATION_SPEED: 1.0,
            
            // Hit-test 결과 표시용 reticle 색상
            RETICLE_COLOR: 0x00ff00,  // 녹색 (0xff0000: 빨강, 0x0000ff: 파랑)
            
            // 조명 설정
            LIGHT_INTENSITY: 0.8,    // 조명 강도 (0.0 ~ 1.0)
            LIGHT_COLOR: 0xffffff,   // 조명 색상 (흰색)
        };
        
        // ===========================================
        // 🎮 전역 변수들
        // ===========================================
        let xrSession = null;
        let xrReferenceSpace = null;
        let xrHitTestSource = null;
        let renderer = null;
        let scene = null;
        let camera = null;
        let ceraModel = null;          // CERA 3D 모델
        let animationMixer = null;     // 애니메이션 믹서
        let currentAnimations = {};    // 현재 재생중인 애니메이션들
        let currentState = 'CHAIR_MODE'; // 현재 애니메이션 상태
        let reticle = null;            // Hit-test 결과 표시용 reticle
        let modelPlaced = false;       // 모델이 배치되었는지 여부
        
        // 애니메이션 상태 관리
        const animationStates = {
            CHAIR_MODE: 'CHAIR_MODE',
            CYLINDER_ACTION: 'CYLINDER_ACTION', 
            STRETCH: 'STRETCH'
        };

        // ===========================================
        // 🚀 WebXR 세션 시작 함수 (개선된 버전)
        // ===========================================
        async function activateXR() {
            try {
                // UI 상태 업데이트
                updateDebug('WebXR 세션 시작 중...');
                const arButton = document.getElementById('arButton');
                const loadingElement = document.getElementById('loading');
                
                arButton.disabled = true;
                arButton.textContent = '초기화 중...';
                loadingElement.style.display = 'block';
                
                // WebXR 지원 확인
                if (!navigator.xr) {
                    throw new Error('이 브라우저는 WebXR을 지원하지 않습니다.');
                }

                updateDebug('AR 세션 지원 확인 중...');
                
                // AR 세션 지원 확인
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    throw new Error('이 디바이스는 AR을 지원하지 않습니다.');
                }

                updateDebug('WebGL 컨텍스트 생성 중...');
                
                // WebGL 컨텍스트 생성
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl', { xrCompatible: true });

                if (!gl) {
                    throw new Error('WebGL을 초기화할 수 없습니다.');
                }

                // Three.js 렌더러 설정
                renderer = new THREE.WebGLRenderer({
                    alpha: true,
                    preserveDrawingBuffer: true,
                    canvas: canvas,
                    context: gl
                });
                renderer.autoClear = false;
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.xr.enabled = true;

                updateDebug('씬 및 조명 설정 중...');

                // 씬 생성 및 조명 설정
                scene = new THREE.Scene();
                
                // 환경광 추가
                const ambientLight = new THREE.AmbientLight(CONFIG.LIGHT_COLOR, 0.4);
                scene.add(ambientLight);
                
                // 직진광 추가
                const directionalLight = new THREE.DirectionalLight(CONFIG.LIGHT_COLOR, CONFIG.LIGHT_INTENSITY);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                // 카메라 설정
                camera = new THREE.PerspectiveCamera();
                camera.matrixAutoUpdate = false;

                updateDebug('CERA 모델 로딩 중...');

                // CERA 모델 로드
                await loadCeraModel();

                updateDebug('Reticle 생성 중...');

                // Reticle (타겟 표시기) 생성
                createReticle();

                updateDebug('AR 세션 요청 중...');

                // AR 세션 시작
                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test']
                });

                updateDebug('XR 렌더 상태 설정 중...');

                xrSession.updateRenderState({
                    baseLayer: new XRWebGLLayer(xrSession, gl)
                });

                // 참조 공간 설정
                xrReferenceSpace = await xrSession.requestReferenceSpace('local');

                updateDebug('Hit-test 소스 생성 중...');

                // Hit-test 소스 생성
                const viewerSpace = await xrSession.requestReferenceSpace('viewer');
                xrHitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

                updateDebug('이벤트 리스너 등록 중...');

                // 터치 이벤트 리스너 (모델 배치 및 애니메이션 제어)
                xrSession.addEventListener('select', onSelect);
                
                // 세션 종료 이벤트 리스너
                xrSession.addEventListener('end', onSessionEnd);

                updateDebug('AR 렌더링 루프 시작...');

                // Canvas를 body에 추가
                document.body.appendChild(canvas);

                // AR 렌더링 루프 시작
                xrSession.requestAnimationFrame(onXRFrame);

                // UI 업데이트
                arButton.style.display = 'none';
                loadingElement.style.display = 'none';
                document.getElementById('arControls').style.display = 'block';
                document.getElementById('debug').style.display = 'block';
                
                updateDebug('AR 세션 시작 완료! 바닥을 찾아보세요...');
                
            } catch (error) {
                console.error('AR 세션 시작 실패:', error);
                updateDebug('오류: ' + error.message);
                
                // UI 복구
                const arButton = document.getElementById('arButton');
                const loadingElement = document.getElementById('loading');
                
                arButton.disabled = false;
                arButton.textContent = 'AR 체험 시작';
                loadingElement.style.display = 'none';
                
                alert('AR 세션을 시작할 수 없습니다: ' + error.message);
            }
        }

        // ===========================================
        // 📦 CERA 모델 로딩 함수 (Draco 압축 지원)
        // ===========================================
        async function loadCeraModel() {
            return new Promise((resolve, reject) => {
                // GLTF 로더 생성
                const loader = new THREE.GLTFLoader();
                
                // Draco 로더 설정 (압축된 geometry 디코딩용)
                const dracoLoader = new THREE.DRACOLoader();
                dracoLoader.setDecoderPath(CONFIG.DRACO_DECODER_PATH);
                dracoLoader.setDecoderConfig({ type: 'js' }); // JavaScript 디코더 사용
                
                // GLTF 로더에 Draco 로더 연결
                loader.setDRACOLoader(dracoLoader);
                
                console.log('Draco 압축 모델 로딩 시작...');
                
                loader.load(
                    CONFIG.MODEL_PATH,
                    (gltf) => {
                        ceraModel = gltf.scene;
                        
                        // 모델 크기 및 회전 설정
                        ceraModel.scale.setScalar(CONFIG.MODEL_SCALE);
                        ceraModel.rotation.y = CONFIG.MODEL_ROTATION_Y;
                        
                        // 그림자 설정
                        ceraModel.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Draco 압축 해제 확인 로그
                                if (child.geometry.attributes.position) {
                                    console.log('Draco 압축 해제 완료:', child.name || 'unnamed mesh');
                                }
                            }
                        });

                        // 애니메이션 믹서 설정
                        if (gltf.animations && gltf.animations.length > 0) {
                            animationMixer = new THREE.AnimationMixer(ceraModel);
                            
                            // 각 애니메이션을 이름으로 저장
                            gltf.animations.forEach(clip => {
                                const action = animationMixer.clipAction(clip);
                                currentAnimations[clip.name] = action;
                                console.log('로드된 애니메이션:', clip.name);
                            });

                            // 기본 애니메이션(Chair Mode) 설정 및 재생
                            if (currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE]) {
                                const chairAction = currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE];
                                chairAction.setLoop(THREE.LoopOnce);
                                chairAction.clampWhenFinished = true;
                                chairAction.play();
                                currentState = animationStates.CHAIR_MODE;
                                console.log('기본 애니메이션(Chair Mode) 재생');
                            }
                        }

                        // Draco 리소스 정리
                        dracoLoader.dispose();
                        console.log('CERA 모델 로딩 완료 (Draco 압축 해제됨)');
                        resolve();
                    },
                    (progress) => {
                        const percentage = Math.round((progress.loaded / progress.total) * 100);
                        console.log('Draco 모델 로딩 진행률:', percentage + '%');
                        
                        // 로딩 진행률 표시 업데이트
                        const loadingElement = document.getElementById('loading');
                        if (loadingElement) {
                            loadingElement.textContent = `모델을 로딩중입니다... ${percentage}%`;
                        }
                    },
                    (error) => {
                        console.error('Draco 모델 로딩 실패:', error);
                        
                        // Draco 디코딩 관련 에러인지 확인
                        if (error.message && error.message.includes('draco')) {
                            reject(new Error('Draco 압축 모델 디코딩 실패: ' + error.message));
                        } else {
                            reject(error);
                        }
                    }
                );
            });
        }

        // ===========================================
        // 🎯 Reticle (타겟 표시기) 생성
        // ===========================================
        function createReticle() {
            const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ 
                color: CONFIG.RETICLE_COLOR,
                transparent: true,
                opacity: 0.8
            });
            
            reticle = new THREE.Mesh(geometry, material);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);
        }

        // ===========================================
        // 🎬 애니메이션 제어 함수들
        // ===========================================
        
        // 애니메이션 전환 함수
        function transitionToAnimation(targetState, reverse = false) {
            if (!animationMixer || !currentAnimations) return;

            console.log(`애니메이션 전환: ${currentState} -> ${targetState} (역재생: ${reverse})`);

            // 현재 재생중인 애니메이션 중지
            Object.values(currentAnimations).forEach(action => {
                action.stop();
            });

            let targetAction;
            
            switch (targetState) {
                case animationStates.CHAIR_MODE:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = CONFIG.ANIMATION_SPEED;
                        targetAction.play();
                    }
                    break;

                case animationStates.CYLINDER_ACTION:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.CYLINDER_ACTION];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = reverse ? -CONFIG.ANIMATION_SPEED : CONFIG.ANIMATION_SPEED;
                        
                        if (reverse) {
                            // 역재생을 위해 끝 지점에서 시작
                            targetAction.time = targetAction.getClip().duration;
                        }
                        
                        targetAction.play();
                        
                        // 애니메이션 완료 후 다음 상태로 전환
                        const mixer = animationMixer;
                        const onAnimationComplete = () => {
                            mixer.removeEventListener('finished', onAnimationComplete);
                            if (reverse) {
                                transitionToAnimation(animationStates.CHAIR_MODE);
                            } else {
                                transitionToAnimation(animationStates.STRETCH);
                            }
                        };
                        mixer.addEventListener('finished', onAnimationComplete);
                    }
                    break;

                case animationStates.STRETCH:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.STRETCH];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = CONFIG.ANIMATION_SPEED;
                        targetAction.play();
                    }
                    break;
            }

            currentState = targetState;
        }

        // 애니메이션 재생 (외부에서 호출 가능)
        function playAnimation() {
            if (!modelPlaced) {
                alert('먼저 모델을 배치해주세요.');
                return;
            }

            switch (currentState) {
                case animationStates.CHAIR_MODE:
                    // Chair -> Cylinder -> Stretch 순서로 재생
                    transitionToAnimation(animationStates.CYLINDER_ACTION, false);
                    break;
                    
                case animationStates.STRETCH:
                    // Stretch -> Cylinder(역재생) -> Chair 순서로 재생
                    transitionToAnimation(animationStates.CYLINDER_ACTION, true);
                    break;
                    
                case animationStates.CYLINDER_ACTION:
                    // 이미 재생중이면 무시
                    console.log('애니메이션이 이미 재생중입니다.');
                    break;
            }
        }

        // 모델 리셋 함수
        function resetModel() {
            if (!modelPlaced) return;
            
            transitionToAnimation(animationStates.CHAIR_MODE);
            console.log('모델이 기본 상태로 리셋되었습니다.');
        }

        // ===========================================
        // 👆 터치/선택 이벤트 처리
        // ===========================================
        function onSelect(event) {
            if (!modelPlaced && reticle.visible) {
                // 모델이 아직 배치되지 않았다면 배치
                const reticlePosition = new THREE.Vector3();
                reticle.getWorldPosition(reticlePosition);
                
                ceraModel.position.copy(reticlePosition);
                scene.add(ceraModel);
                
                modelPlaced = true;
                reticle.visible = false;
                
                console.log('CERA 모델이 배치되었습니다.');
            } else if (modelPlaced) {
                // 모델이 이미 배치되었다면 애니메이션 제어
                playAnimation();
            }
        }

        // ===========================================
        // 🎨 XR 렌더링 루프
        // ===========================================
        function onXRFrame(time, frame) {
            xrSession.requestAnimationFrame(onXRFrame);

            const referenceSpace = xrReferenceSpace;
            const pose = frame.getViewerPose(referenceSpace);

            if (pose) {
                const view = pose.views[0];
                const viewport = xrSession.renderState.baseLayer.getViewport(view);
                
                renderer.setSize(viewport.width, viewport.height);

                // 카메라 매트릭스 업데이트
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.updateMatrixWorld(true);

                // Hit-test 결과 처리 (모델이 아직 배치되지 않았을 때만)
                if (xrHitTestSource && !modelPlaced) {
                    const hitTestResults = frame.getHitTestResults(xrHitTestSource);
                    
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const hitPose = hit.getPose(referenceSpace);
                        
                        reticle.visible = true;
                        reticle.matrix.fromArray(hitPose.transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }

                // 애니메이션 업데이트
                if (animationMixer) {
                    animationMixer.update(0.016); // 약 60fps
                }

                // WebXR 프레임버퍼에 바인딩
                const glLayer = xrSession.renderState.baseLayer;
                renderer.getContext().bindFramebuffer(renderer.getContext().FRAMEBUFFER, glLayer.framebuffer);

                // 씬 렌더링
                renderer.render(scene, camera);
            }
        }

        // ===========================================
        // 🛠️ 유틸리티 함수들
        // ===========================================
        
        // 브라우저 호환성 체크
        function checkCompatibility() {
            if (!navigator.xr) {
                document.querySelector('.ar-button').disabled = true;
                document.querySelector('.ar-button').textContent = 'WebXR 미지원';
                document.querySelector('.info').innerHTML = '<p style="color: #ff6b6b;">❌ 이 브라우저는 WebXR을 지원하지 않습니다.</p>';
                return false;
            }
            return true;
        }

        // 페이지 로드 시 호환성 체크 (개선된 버전)
        window.addEventListener('load', async () => {
            updateDebug('페이지 로딩 완료, 호환성 확인 중...');
            await checkCompatibility();
        });

        // 세션 종료 처리
        function endXRSession() {
            if (xrSession) {
                xrSession.end();
                xrSession = null;
                
                // UI 리셋
                document.querySelector('.container').style.display = 'block';
                document.getElementById('arControls').style.display = 'none';
                
                // 변수 초기화
                modelPlaced = false;
                currentState = animationStates.CHAIR_MODE;
                
                // Canvas 제거
                const canvas = document.querySelector('canvas');
                if (canvas) {
                    canvas.remove();
                }
                
                console.log('AR 세션이 종료되었습니다.');
            }
        }

        // 페이지 언로드 시 세션 정리
        window.addEventListener('beforeunload', endXRSession);
        
    </script>
</body>
</html>