<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CERA WebAR</title>
    
    <!-- Three.js 라이브러리 -->
    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .container {
            max-width: 400px;
            width: 100%;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            font-size: 1.1rem;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .ar-button {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E);
            color: white;
            border: none;
            padding: 18px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.4);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .ar-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 25px rgba(255, 107, 107, 0.6);
        }

        .ar-button:active {
            transform: translateY(0px);
        }

        .info {
            margin-top: 25px;
            font-size: 0.9rem;
            opacity: 0.8;
            line-height: 1.5;
        }

        .loading {
            display: none;
            margin-top: 20px;
            font-size: 1rem;
        }

        .controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 25px;
            z-index: 1000;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CERA</h1>
        <p class="subtitle">증강현실로 체험해보세요</p>
        
        <button class="ar-button" onclick="activateXR()">AR 체험 시작</button>
        
        <div class="loading" id="loading">
            모델을 로딩중입니다...
        </div>
        
        <div class="info">
            <p>📱 Android 디바이스에서 Chrome 브라우저 사용 권장</p>
            <p>🎯 평평한 바닥이나 테이블을 찾아 모델을 배치하세요</p>
            <p>✋ 화면을 탭하여 애니메이션을 제어할 수 있습니다</p>
        </div>
    </div>

    <!-- AR 제어 버튼들 (AR 모드에서만 표시) -->
    <div class="controls" id="arControls">
        <button class="control-button" onclick="playAnimation()">애니메이션 재생</button>
        <button class="control-button" onclick="resetModel()">모델 리셋</button>
    </div>

    <script>
        // ===========================================
        // 🔧 주요 설정 파라미터들 (이 부분을 수정하세요)
        // ===========================================
        
        const CONFIG = {
            // 모델 파일 경로 (GLB 파일명을 여기서 수정)
            MODEL_PATH: './CERA_V11.glb',
            
            // 애니메이션 이름들 (GLB 파일의 애니메이션 이름과 정확히 일치해야 함)
            ANIMATIONS: {
                CHAIR_MODE: 'CERA_V11_ChairMode(1)_Baked',      // 기본 자세 (1프레임)
                CYLINDER_ACTION: 'CERA_V11_CylinderAction(240)_Baked', // 메인 애니메이션 (240프레임)
                STRETCH: 'CERA_V11_Stretch(1)_Baked'           // 끝 자세 (1프레임)
            },
            
            // 모델 크기 배율 (1.0 = 원본 크기, 0.5 = 절반 크기)
            MODEL_SCALE: 1.0,
            
            // 모델의 기본 회전 (Y축 기준, 라디안 단위)
            MODEL_ROTATION_Y: 0,
            
            // 애니메이션 재생 속도 (1.0 = 정상 속도, 0.5 = 절반 속도)
            ANIMATION_SPEED: 1.0,
            
            // Hit-test 결과 표시용 reticle 색상
            RETICLE_COLOR: 0x00ff00,  // 녹색 (0xff0000: 빨강, 0x0000ff: 파랑)
            
            // 조명 설정
            LIGHT_INTENSITY: 0.8,    // 조명 강도 (0.0 ~ 1.0)
            LIGHT_COLOR: 0xffffff,   // 조명 색상 (흰색)
        };
        
        // ===========================================
        // 🎮 전역 변수들
        // ===========================================
        let xrSession = null;
        let xrReferenceSpace = null;
        let xrHitTestSource = null;
        let renderer = null;
        let scene = null;
        let camera = null;
        let ceraModel = null;          // CERA 3D 모델
        let animationMixer = null;     // 애니메이션 믹서
        let currentAnimations = {};    // 현재 재생중인 애니메이션들
        let currentState = 'CHAIR_MODE'; // 현재 애니메이션 상태
        let reticle = null;            // Hit-test 결과 표시용 reticle
        let modelPlaced = false;       // 모델이 배치되었는지 여부
        
        // 애니메이션 상태 관리
        const animationStates = {
            CHAIR_MODE: 'CHAIR_MODE',
            CYLINDER_ACTION: 'CYLINDER_ACTION', 
            STRETCH: 'STRETCH'
        };

        // ===========================================
        // 🚀 WebXR 세션 시작 함수
        // ===========================================
        async function activateXR() {
            try {
                // 로딩 표시
                document.getElementById('loading').style.display = 'block';
                
                // WebXR 지원 확인
                if (!navigator.xr) {
                    alert('이 브라우저는 WebXR을 지원하지 않습니다.');
                    return;
                }

                // AR 세션 지원 확인
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    alert('이 디바이스는 AR을 지원하지 않습니다.');
                    return;
                }

                // WebGL 컨텍스트 생성
                const canvas = document.createElement('canvas');
                document.body.appendChild(canvas);
                const gl = canvas.getContext('webgl', { xrCompatible: true });

                if (!gl) {
                    alert('WebGL을 초기화할 수 없습니다.');
                    return;
                }

                // Three.js 렌더러 설정
                renderer = new THREE.WebGLRenderer({
                    alpha: true,
                    preserveDrawingBuffer: true,
                    canvas: canvas,
                    context: gl
                });
                renderer.autoClear = false;
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // 씬 생성 및 조명 설정
                scene = new THREE.Scene();
                
                // 환경광 추가
                const ambientLight = new THREE.AmbientLight(CONFIG.LIGHT_COLOR, 0.4);
                scene.add(ambientLight);
                
                // 직진광 추가
                const directionalLight = new THREE.DirectionalLight(CONFIG.LIGHT_COLOR, CONFIG.LIGHT_INTENSITY);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                // 카메라 설정
                camera = new THREE.PerspectiveCamera();
                camera.matrixAutoUpdate = false;

                // CERA 모델 로드
                await loadCeraModel();

                // Reticle (타겟 표시기) 생성
                createReticle();

                // AR 세션 시작
                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test']
                });

                xrSession.updateRenderState({
                    baseLayer: new XRWebGLLayer(xrSession, gl)
                });

                // 참조 공간 설정
                xrReferenceSpace = await xrSession.requestReferenceSpace('local');

                // Hit-test 소스 생성
                const viewerSpace = await xrSession.requestReferenceSpace('viewer');
                xrHitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

                // 터치 이벤트 리스너 (모델 배치 및 애니메이션 제어)
                xrSession.addEventListener('select', onSelect);

                // AR 렌더링 루프 시작
                xrSession.requestAnimationFrame(onXRFrame);

                // UI 업데이트
                document.querySelector('.container').style.display = 'none';
                document.getElementById('arControls').style.display = 'block';
                
            } catch (error) {
                console.error('AR 세션 시작 실패:', error);
                alert('AR 세션을 시작할 수 없습니다: ' + error.message);
                document.getElementById('loading').style.display = 'none';
            }
        }

        // ===========================================
        // 📦 CERA 모델 로딩 함수
        // ===========================================
        async function loadCeraModel() {
            return new Promise((resolve, reject) => {
                const loader = new THREE.GLTFLoader();
                
                loader.load(
                    CONFIG.MODEL_PATH,
                    (gltf) => {
                        ceraModel = gltf.scene;
                        
                        // 모델 크기 및 회전 설정
                        ceraModel.scale.setScalar(CONFIG.MODEL_SCALE);
                        ceraModel.rotation.y = CONFIG.MODEL_ROTATION_Y;
                        
                        // 그림자 설정
                        ceraModel.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        // 애니메이션 믹서 설정
                        if (gltf.animations && gltf.animations.length > 0) {
                            animationMixer = new THREE.AnimationMixer(ceraModel);
                            
                            // 각 애니메이션을 이름으로 저장
                            gltf.animations.forEach(clip => {
                                const action = animationMixer.clipAction(clip);
                                currentAnimations[clip.name] = action;
                                console.log('로드된 애니메이션:', clip.name);
                            });

                            // 기본 애니메이션(Chair Mode) 설정 및 재생
                            if (currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE]) {
                                const chairAction = currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE];
                                chairAction.setLoop(THREE.LoopOnce);
                                chairAction.clampWhenFinished = true;
                                chairAction.play();
                                currentState = animationStates.CHAIR_MODE;
                                console.log('기본 애니메이션(Chair Mode) 재생');
                            }
                        }

                        console.log('CERA 모델 로딩 완료');
                        resolve();
                    },
                    (progress) => {
                        console.log('로딩 진행률:', (progress.loaded / progress.total * 100) + '%');
                    },
                    (error) => {
                        console.error('모델 로딩 실패:', error);
                        reject(error);
                    }
                );
            });
        }

        // ===========================================
        // 🎯 Reticle (타겟 표시기) 생성
        // ===========================================
        function createReticle() {
            const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ 
                color: CONFIG.RETICLE_COLOR,
                transparent: true,
                opacity: 0.8
            });
            
            reticle = new THREE.Mesh(geometry, material);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);
        }

        // ===========================================
        // 🎬 애니메이션 제어 함수들
        // ===========================================
        
        // 애니메이션 전환 함수
        function transitionToAnimation(targetState, reverse = false) {
            if (!animationMixer || !currentAnimations) return;

            console.log(`애니메이션 전환: ${currentState} -> ${targetState} (역재생: ${reverse})`);

            // 현재 재생중인 애니메이션 중지
            Object.values(currentAnimations).forEach(action => {
                action.stop();
            });

            let targetAction;
            
            switch (targetState) {
                case animationStates.CHAIR_MODE:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = CONFIG.ANIMATION_SPEED;
                        targetAction.play();
                    }
                    break;

                case animationStates.CYLINDER_ACTION:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.CYLINDER_ACTION];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = reverse ? -CONFIG.ANIMATION_SPEED : CONFIG.ANIMATION_SPEED;
                        
                        if (reverse) {
                            // 역재생을 위해 끝 지점에서 시작
                            targetAction.time = targetAction.getClip().duration;
                        }
                        
                        targetAction.play();
                        
                        // 애니메이션 완료 후 다음 상태로 전환
                        const mixer = animationMixer;
                        const onAnimationComplete = () => {
                            mixer.removeEventListener('finished', onAnimationComplete);
                            if (reverse) {
                                transitionToAnimation(animationStates.CHAIR_MODE);
                            } else {
                                transitionToAnimation(animationStates.STRETCH);
                            }
                        };
                        mixer.addEventListener('finished', onAnimationComplete);
                    }
                    break;

                case animationStates.STRETCH:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.STRETCH];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = CONFIG.ANIMATION_SPEED;
                        targetAction.play();
                    }
                    break;
            }

            currentState = targetState;
        }

        // 애니메이션 재생 (외부에서 호출 가능)
        function playAnimation() {
            if (!modelPlaced) {
                alert('먼저 모델을 배치해주세요.');
                return;
            }

            switch (currentState) {
                case animationStates.CHAIR_MODE:
                    // Chair -> Cylinder -> Stretch 순서로 재생
                    transitionToAnimation(animationStates.CYLINDER_ACTION, false);
                    break;
                    
                case animationStates.STRETCH:
                    // Stretch -> Cylinder(역재생) -> Chair 순서로 재생
                    transitionToAnimation(animationStates.CYLINDER_ACTION, true);
                    break;
                    
                case animationStates.CYLINDER_ACTION:
                    // 이미 재생중이면 무시
                    console.log('애니메이션이 이미 재생중입니다.');
                    break;
            }
        }

        // 모델 리셋 함수
        function resetModel() {
            if (!modelPlaced) return;
            
            transitionToAnimation(animationStates.CHAIR_MODE);
            console.log('모델이 기본 상태로 리셋되었습니다.');
        }

        // ===========================================
        // 👆 터치/선택 이벤트 처리
        // ===========================================
        function onSelect(event) {
            if (!modelPlaced && reticle.visible) {
                // 모델이 아직 배치되지 않았다면 배치
                const reticlePosition = new THREE.Vector3();
                reticle.getWorldPosition(reticlePosition);
                
                ceraModel.position.copy(reticlePosition);
                scene.add(ceraModel);
                
                modelPlaced = true;
                reticle.visible = false;
                
                console.log('CERA 모델이 배치되었습니다.');
            } else if (modelPlaced) {
                // 모델이 이미 배치되었다면 애니메이션 제어
                playAnimation();
            }
        }

        // ===========================================
        // 🎨 XR 렌더링 루프
        // ===========================================
        function onXRFrame(time, frame) {
            xrSession.requestAnimationFrame(onXRFrame);

            const referenceSpace = xrReferenceSpace;
            const pose = frame.getViewerPose(referenceSpace);

            if (pose) {
                const view = pose.views[0];
                const viewport = xrSession.renderState.baseLayer.getViewport(view);
                
                renderer.setSize(viewport.width, viewport.height);

                // 카메라 매트릭스 업데이트
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.updateMatrixWorld(true);

                // Hit-test 결과 처리 (모델이 아직 배치되지 않았을 때만)
                if (xrHitTestSource && !modelPlaced) {
                    const hitTestResults = frame.getHitTestResults(xrHitTestSource);
                    
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const hitPose = hit.getPose(referenceSpace);
                        
                        reticle.visible = true;
                        reticle.matrix.fromArray(hitPose.transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }

                // 애니메이션 업데이트
                if (animationMixer) {
                    animationMixer.update(0.016); // 약 60fps
                }

                // WebXR 프레임버퍼에 바인딩
                const glLayer = xrSession.renderState.baseLayer;
                renderer.getContext().bindFramebuffer(renderer.getContext().FRAMEBUFFER, glLayer.framebuffer);

                // 씬 렌더링
                renderer.render(scene, camera);
            }
        }

        // ===========================================
        // 🛠️ 유틸리티 함수들
        // ===========================================
        
        // 브라우저 호환성 체크
        function checkCompatibility() {
            if (!navigator.xr) {
                document.querySelector('.ar-button').disabled = true;
                document.querySelector('.ar-button').textContent = 'WebXR 미지원';
                document.querySelector('.info').innerHTML = '<p style="color: #ff6b6b;">❌ 이 브라우저는 WebXR을 지원하지 않습니다.</p>';
                return false;
            }
            return true;
        }

        // 페이지 로드 시 호환성 체크
        window.addEventListener('load', () => {
            checkCompatibility();
        });

        // 세션 종료 처리
        function endXRSession() {
            if (xrSession) {
                xrSession.end();
                xrSession = null;
                
                // UI 리셋
                document.querySelector('.container').style.display = 'block';
                document.getElementById('arControls').style.display = 'none';
                
                // 변수 초기화
                modelPlaced = false;
                currentState = animationStates.CHAIR_MODE;
                
                // Canvas 제거
                const canvas = document.querySelector('canvas');
                if (canvas) {
                    canvas.remove();
                }
                
                console.log('AR 세션이 종료되었습니다.');
            }
        }

        // 페이지 언로드 시 세션 정리
        window.addEventListener('beforeunload', endXRSession);
        
    </script>
</body>
</html>