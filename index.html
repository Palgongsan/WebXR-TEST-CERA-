<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CERA WebAR</title>
    
    <!-- Three.js ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Draco ì••ì¶• ì§€ì›ì„ ìœ„í•œ ë¡œë” -->
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/DRACOLoader.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: #000000;
            color: white;
            text-align: center;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .ar-button {
            background: #333333;
            color: white;
            border: 2px solid #666666;
            padding: 20px 50px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .ar-button:hover {
            background: #555555;
            border-color: #888888;
        }

        .ar-button:active {
            background: #222222;
        }

        .ar-button:disabled {
            background: #111111;
            color: #555555;
            cursor: not-allowed;
            border-color: #333333;
        }

        .loading {
            display: none;
            margin-top: 20px;
            font-size: 1rem;
        }

        .controls {
            display: none;
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            z-index: 1000;
            border: 1px solid #333333;
        }

        .control-button {
            background: #333333;
            color: white;
            border: 1px solid #666666;
            padding: 12px 20px;
            margin: 0 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s ease;
        }

        .control-button:hover {
            background: #555555;
        }

        .control-button:active {
            background: #222222;
        }

        .debug {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-width: 300px;
            z-index: 1001;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <button class="ar-button" id="arButton" onclick="activateXR()">AR ì²´í—˜ ì‹œì‘</button>
    
    <div class="loading" id="loading">
        ëª¨ë¸ì„ ë¡œë”©ì¤‘ì…ë‹ˆë‹¤...
    </div>
    
    <!-- ë””ë²„ê·¸ ì •ë³´ í‘œì‹œ -->
    <div class="debug" id="debug">
        ìƒíƒœ: ëŒ€ê¸°ì¤‘
    </div>

    <!-- AR ì œì–´ ë²„íŠ¼ë“¤ -->
    <div class="controls" id="arControls">
        <button class="control-button" onclick="playAnimation()">ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ</button>
        <button class="control-button" onclick="resetModel()">ëª¨ë¸ ë¦¬ì…‹</button>
        <button class="control-button" onclick="endXRSession()">AR ì¢…ë£Œ</button>
    </div>

    <script>
        // ===========================================
        // ğŸ”§ ì£¼ìš” ì„¤ì • íŒŒë¼ë¯¸í„°ë“¤ (ì´ ë¶€ë¶„ì„ ìˆ˜ì •í•˜ì„¸ìš”)
        // ===========================================
        
        const CONFIG = {
            // ëª¨ë¸ íŒŒì¼ ê²½ë¡œ (GLB íŒŒì¼ëª…ì„ ì—¬ê¸°ì„œ ìˆ˜ì •)
            MODEL_PATH: './CERA_V11.glb',
            
            // Draco ë””ì½”ë” ê²½ë¡œ (CDNì—ì„œ ìë™ìœ¼ë¡œ ë¡œë“œë¨)
            DRACO_DECODER_PATH: 'https://unpkg.com/three@0.126.0/examples/js/libs/draco/',
            
            // ì• ë‹ˆë©”ì´ì…˜ ì´ë¦„ë“¤ (GLB íŒŒì¼ì˜ ì• ë‹ˆë©”ì´ì…˜ ì´ë¦„ê³¼ ì •í™•íˆ ì¼ì¹˜í•´ì•¼ í•¨)
            ANIMATIONS: {
                CHAIR_MODE: 'CERA_V11_ChairMode(1)_Baked',      // ê¸°ë³¸ ìì„¸ (1í”„ë ˆì„)
                CYLINDER_ACTION: 'CERA_V11_CylinderAction(240)_Baked', // ë©”ì¸ ì• ë‹ˆë©”ì´ì…˜ (240í”„ë ˆì„)
                STRETCH: 'CERA_V11_Stretch(1)_Baked'           // ë ìì„¸ (1í”„ë ˆì„)
            },
            
            // ëª¨ë¸ í¬ê¸° ë°°ìœ¨ (1.0 = ì›ë³¸ í¬ê¸°, 0.5 = ì ˆë°˜ í¬ê¸°)
            MODEL_SCALE: 1.0,
            
            // ëª¨ë¸ì˜ ê¸°ë³¸ íšŒì „ (Yì¶• ê¸°ì¤€, ë¼ë””ì•ˆ ë‹¨ìœ„)
            MODEL_ROTATION_Y: 0,
            
            // ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ ì†ë„ (1.0 = ì •ìƒ ì†ë„, 0.5 = ì ˆë°˜ ì†ë„)
            ANIMATION_SPEED: 1.0,
            
            // Hit-test ê²°ê³¼ í‘œì‹œìš© reticle ìƒ‰ìƒ
            RETICLE_COLOR: 0x00ff00,  // ë…¹ìƒ‰ (0xff0000: ë¹¨ê°•, 0x0000ff: íŒŒë‘)
            
            // ì¡°ëª… ì„¤ì •
            LIGHT_INTENSITY: 0.8,    // ì¡°ëª… ê°•ë„ (0.0 ~ 1.0)
            LIGHT_COLOR: 0xffffff,   // ì¡°ëª… ìƒ‰ìƒ (í°ìƒ‰)
        };
        
        // ===========================================
        // ğŸ® ì „ì—­ ë³€ìˆ˜ë“¤
        // ===========================================
        let xrSession = null;
        let xrReferenceSpace = null;
        let xrHitTestSource = null;
        let renderer = null;
        let scene = null;
        let camera = null;
        let ceraModel = null;          // CERA 3D ëª¨ë¸
        let animationMixer = null;     // ì• ë‹ˆë©”ì´ì…˜ ë¯¹ì„œ
        let currentAnimations = {};    // í˜„ì¬ ì¬ìƒì¤‘ì¸ ì• ë‹ˆë©”ì´ì…˜ë“¤
        let currentState = 'CHAIR_MODE'; // í˜„ì¬ ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ
        let reticle = null;            // Hit-test ê²°ê³¼ í‘œì‹œìš© reticle
        let modelPlaced = false;       // ëª¨ë¸ì´ ë°°ì¹˜ë˜ì—ˆëŠ”ì§€ ì—¬ë¶€
        
        // ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ ê´€ë¦¬
        const animationStates = {
            CHAIR_MODE: 'CHAIR_MODE',
            CYLINDER_ACTION: 'CYLINDER_ACTION', 
            STRETCH: 'STRETCH'
        };

        // ===========================================
        // ğŸš€ WebXR ì„¸ì…˜ ì‹œì‘ í•¨ìˆ˜ (ê°œì„ ëœ ë²„ì „)
        // ===========================================
        async function activateXR() {
            try {
                // UI ìƒíƒœ ì—…ë°ì´íŠ¸
                updateDebug('WebXR ì„¸ì…˜ ì‹œì‘ ì¤‘...');
                const arButton = document.getElementById('arButton');
                const loadingElement = document.getElementById('loading');
                
                arButton.disabled = true;
                arButton.textContent = 'ì´ˆê¸°í™” ì¤‘...';
                loadingElement.style.display = 'block';
                
                // WebXR ì§€ì› í™•ì¸
                if (!navigator.xr) {
                    throw new Error('ì´ ë¸Œë¼ìš°ì €ëŠ” WebXRì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                }

                updateDebug('AR ì„¸ì…˜ ì§€ì› í™•ì¸ ì¤‘...');
                
                // AR ì„¸ì…˜ ì§€ì› í™•ì¸
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    throw new Error('ì´ ë””ë°”ì´ìŠ¤ëŠ” ARì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                }

                updateDebug('WebGL ì»¨í…ìŠ¤íŠ¸ ìƒì„± ì¤‘...');
                
                // WebGL ì»¨í…ìŠ¤íŠ¸ ìƒì„±
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl', { xrCompatible: true });

                if (!gl) {
                    throw new Error('WebGLì„ ì´ˆê¸°í™”í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }

                // Three.js ë Œë”ëŸ¬ ì„¤ì •
                renderer = new THREE.WebGLRenderer({
                    alpha: true,
                    preserveDrawingBuffer: true,
                    canvas: canvas,
                    context: gl
                });
                renderer.autoClear = false;
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.xr.enabled = true;

                updateDebug('ì”¬ ë° ì¡°ëª… ì„¤ì • ì¤‘...');

                // ì”¬ ìƒì„± ë° ì¡°ëª… ì„¤ì •
                scene = new THREE.Scene();
                
                // í™˜ê²½ê´‘ ì¶”ê°€
                const ambientLight = new THREE.AmbientLight(CONFIG.LIGHT_COLOR, 0.4);
                scene.add(ambientLight);
                
                // ì§ì§„ê´‘ ì¶”ê°€
                const directionalLight = new THREE.DirectionalLight(CONFIG.LIGHT_COLOR, CONFIG.LIGHT_INTENSITY);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                // ì¹´ë©”ë¼ ì„¤ì •
                camera = new THREE.PerspectiveCamera();
                camera.matrixAutoUpdate = false;

                updateDebug('CERA ëª¨ë¸ ë¡œë”© ì¤‘...');

                // CERA ëª¨ë¸ ë¡œë“œ
                await loadCeraModel();

                updateDebug('Reticle ìƒì„± ì¤‘...');

                // Reticle (íƒ€ê²Ÿ í‘œì‹œê¸°) ìƒì„±
                createReticle();

                updateDebug('AR ì„¸ì…˜ ìš”ì²­ ì¤‘...');

                // AR ì„¸ì…˜ ì‹œì‘
                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test']
                });

                updateDebug('XR ë Œë” ìƒíƒœ ì„¤ì • ì¤‘...');

                xrSession.updateRenderState({
                    baseLayer: new XRWebGLLayer(xrSession, gl)
                });

                // ì°¸ì¡° ê³µê°„ ì„¤ì •
                xrReferenceSpace = await xrSession.requestReferenceSpace('local');

                updateDebug('Hit-test ì†ŒìŠ¤ ìƒì„± ì¤‘...');

                // Hit-test ì†ŒìŠ¤ ìƒì„±
                const viewerSpace = await xrSession.requestReferenceSpace('viewer');
                xrHitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

                updateDebug('ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ì¤‘...');

                // í„°ì¹˜ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ëª¨ë¸ ë°°ì¹˜ ë° ì• ë‹ˆë©”ì´ì…˜ ì œì–´)
                xrSession.addEventListener('select', onSelect);
                
                // ì„¸ì…˜ ì¢…ë£Œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
                xrSession.addEventListener('end', onSessionEnd);

                updateDebug('AR ë Œë”ë§ ë£¨í”„ ì‹œì‘...');

                // Canvasë¥¼ bodyì— ì¶”ê°€
                document.body.appendChild(canvas);

                // AR ë Œë”ë§ ë£¨í”„ ì‹œì‘
                xrSession.requestAnimationFrame(onXRFrame);

                // UI ì—…ë°ì´íŠ¸
                arButton.style.display = 'none';
                loadingElement.style.display = 'none';
                document.getElementById('arControls').style.display = 'block';
                document.getElementById('debug').style.display = 'block';
                
                updateDebug('AR ì„¸ì…˜ ì‹œì‘ ì™„ë£Œ! ë°”ë‹¥ì„ ì°¾ì•„ë³´ì„¸ìš”...');
                
            } catch (error) {
                console.error('AR ì„¸ì…˜ ì‹œì‘ ì‹¤íŒ¨:', error);
                updateDebug('ì˜¤ë¥˜: ' + error.message);
                
                // UI ë³µêµ¬
                const arButton = document.getElementById('arButton');
                const loadingElement = document.getElementById('loading');
                
                arButton.disabled = false;
                arButton.textContent = 'AR ì²´í—˜ ì‹œì‘';
                loadingElement.style.display = 'none';
                
                alert('AR ì„¸ì…˜ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // ===========================================
        // ğŸ“¦ CERA ëª¨ë¸ ë¡œë”© í•¨ìˆ˜ (Draco ì••ì¶• ì§€ì›)
        // ===========================================
        async function loadCeraModel() {
            return new Promise((resolve, reject) => {
                // GLTF ë¡œë” ìƒì„±
                const loader = new THREE.GLTFLoader();
                
                // Draco ë¡œë” ì„¤ì • (ì••ì¶•ëœ geometry ë””ì½”ë”©ìš©)
                const dracoLoader = new THREE.DRACOLoader();
                dracoLoader.setDecoderPath(CONFIG.DRACO_DECODER_PATH);
                dracoLoader.setDecoderConfig({ type: 'js' }); // JavaScript ë””ì½”ë” ì‚¬ìš©
                
                // GLTF ë¡œë”ì— Draco ë¡œë” ì—°ê²°
                loader.setDRACOLoader(dracoLoader);
                
                console.log('Draco ì••ì¶• ëª¨ë¸ ë¡œë”© ì‹œì‘...');
                
                loader.load(
                    CONFIG.MODEL_PATH,
                    (gltf) => {
                        ceraModel = gltf.scene;
                        
                        // ëª¨ë¸ í¬ê¸° ë° íšŒì „ ì„¤ì •
                        ceraModel.scale.setScalar(CONFIG.MODEL_SCALE);
                        ceraModel.rotation.y = CONFIG.MODEL_ROTATION_Y;
                        
                        // ê·¸ë¦¼ì ì„¤ì •
                        ceraModel.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Draco ì••ì¶• í•´ì œ í™•ì¸ ë¡œê·¸
                                if (child.geometry.attributes.position) {
                                    console.log('Draco ì••ì¶• í•´ì œ ì™„ë£Œ:', child.name || 'unnamed mesh');
                                }
                            }
                        });

                        // ì• ë‹ˆë©”ì´ì…˜ ë¯¹ì„œ ì„¤ì •
                        if (gltf.animations && gltf.animations.length > 0) {
                            animationMixer = new THREE.AnimationMixer(ceraModel);
                            
                            // ê° ì• ë‹ˆë©”ì´ì…˜ì„ ì´ë¦„ìœ¼ë¡œ ì €ì¥
                            gltf.animations.forEach(clip => {
                                const action = animationMixer.clipAction(clip);
                                currentAnimations[clip.name] = action;
                                console.log('ë¡œë“œëœ ì• ë‹ˆë©”ì´ì…˜:', clip.name);
                            });

                            // ê¸°ë³¸ ì• ë‹ˆë©”ì´ì…˜(Chair Mode) ì„¤ì • ë° ì¬ìƒ
                            if (currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE]) {
                                const chairAction = currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE];
                                chairAction.setLoop(THREE.LoopOnce);
                                chairAction.clampWhenFinished = true;
                                chairAction.play();
                                currentState = animationStates.CHAIR_MODE;
                                console.log('ê¸°ë³¸ ì• ë‹ˆë©”ì´ì…˜(Chair Mode) ì¬ìƒ');
                            }
                        }

                        // Draco ë¦¬ì†ŒìŠ¤ ì •ë¦¬
                        dracoLoader.dispose();
                        console.log('CERA ëª¨ë¸ ë¡œë”© ì™„ë£Œ (Draco ì••ì¶• í•´ì œë¨)');
                        resolve();
                    },
                    (progress) => {
                        const percentage = Math.round((progress.loaded / progress.total) * 100);
                        console.log('Draco ëª¨ë¸ ë¡œë”© ì§„í–‰ë¥ :', percentage + '%');
                        
                        // ë¡œë”© ì§„í–‰ë¥  í‘œì‹œ ì—…ë°ì´íŠ¸
                        const loadingElement = document.getElementById('loading');
                        if (loadingElement) {
                            loadingElement.textContent = `ëª¨ë¸ì„ ë¡œë”©ì¤‘ì…ë‹ˆë‹¤... ${percentage}%`;
                        }
                    },
                    (error) => {
                        console.error('Draco ëª¨ë¸ ë¡œë”© ì‹¤íŒ¨:', error);
                        
                        // Draco ë””ì½”ë”© ê´€ë ¨ ì—ëŸ¬ì¸ì§€ í™•ì¸
                        if (error.message && error.message.includes('draco')) {
                            reject(new Error('Draco ì••ì¶• ëª¨ë¸ ë””ì½”ë”© ì‹¤íŒ¨: ' + error.message));
                        } else {
                            reject(error);
                        }
                    }
                );
            });
        }

        // ===========================================
        // ğŸ¯ Reticle (íƒ€ê²Ÿ í‘œì‹œê¸°) ìƒì„±
        // ===========================================
        function createReticle() {
            const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ 
                color: CONFIG.RETICLE_COLOR,
                transparent: true,
                opacity: 0.8
            });
            
            reticle = new THREE.Mesh(geometry, material);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);
        }

        // ===========================================
        // ğŸ¬ ì• ë‹ˆë©”ì´ì…˜ ì œì–´ í•¨ìˆ˜ë“¤
        // ===========================================
        
        // ì• ë‹ˆë©”ì´ì…˜ ì „í™˜ í•¨ìˆ˜
        function transitionToAnimation(targetState, reverse = false) {
            if (!animationMixer || !currentAnimations) return;

            console.log(`ì• ë‹ˆë©”ì´ì…˜ ì „í™˜: ${currentState} -> ${targetState} (ì—­ì¬ìƒ: ${reverse})`);

            // í˜„ì¬ ì¬ìƒì¤‘ì¸ ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì§€
            Object.values(currentAnimations).forEach(action => {
                action.stop();
            });

            let targetAction;
            
            switch (targetState) {
                case animationStates.CHAIR_MODE:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.CHAIR_MODE];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = CONFIG.ANIMATION_SPEED;
                        targetAction.play();
                    }
                    break;

                case animationStates.CYLINDER_ACTION:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.CYLINDER_ACTION];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = reverse ? -CONFIG.ANIMATION_SPEED : CONFIG.ANIMATION_SPEED;
                        
                        if (reverse) {
                            // ì—­ì¬ìƒì„ ìœ„í•´ ë ì§€ì ì—ì„œ ì‹œì‘
                            targetAction.time = targetAction.getClip().duration;
                        }
                        
                        targetAction.play();
                        
                        // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ë‹¤ìŒ ìƒíƒœë¡œ ì „í™˜
                        const mixer = animationMixer;
                        const onAnimationComplete = () => {
                            mixer.removeEventListener('finished', onAnimationComplete);
                            if (reverse) {
                                transitionToAnimation(animationStates.CHAIR_MODE);
                            } else {
                                transitionToAnimation(animationStates.STRETCH);
                            }
                        };
                        mixer.addEventListener('finished', onAnimationComplete);
                    }
                    break;

                case animationStates.STRETCH:
                    targetAction = currentAnimations[CONFIG.ANIMATIONS.STRETCH];
                    if (targetAction) {
                        targetAction.reset();
                        targetAction.setLoop(THREE.LoopOnce);
                        targetAction.clampWhenFinished = true;
                        targetAction.timeScale = CONFIG.ANIMATION_SPEED;
                        targetAction.play();
                    }
                    break;
            }

            currentState = targetState;
        }

        // ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ (ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥)
        function playAnimation() {
            if (!modelPlaced) {
                alert('ë¨¼ì € ëª¨ë¸ì„ ë°°ì¹˜í•´ì£¼ì„¸ìš”.');
                return;
            }

            switch (currentState) {
                case animationStates.CHAIR_MODE:
                    // Chair -> Cylinder -> Stretch ìˆœì„œë¡œ ì¬ìƒ
                    transitionToAnimation(animationStates.CYLINDER_ACTION, false);
                    break;
                    
                case animationStates.STRETCH:
                    // Stretch -> Cylinder(ì—­ì¬ìƒ) -> Chair ìˆœì„œë¡œ ì¬ìƒ
                    transitionToAnimation(animationStates.CYLINDER_ACTION, true);
                    break;
                    
                case animationStates.CYLINDER_ACTION:
                    // ì´ë¯¸ ì¬ìƒì¤‘ì´ë©´ ë¬´ì‹œ
                    console.log('ì• ë‹ˆë©”ì´ì…˜ì´ ì´ë¯¸ ì¬ìƒì¤‘ì…ë‹ˆë‹¤.');
                    break;
            }
        }

        // ëª¨ë¸ ë¦¬ì…‹ í•¨ìˆ˜
        function resetModel() {
            if (!modelPlaced) return;
            
            transitionToAnimation(animationStates.CHAIR_MODE);
            console.log('ëª¨ë¸ì´ ê¸°ë³¸ ìƒíƒœë¡œ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤.');
        }

        // ===========================================
        // ğŸ‘† í„°ì¹˜/ì„ íƒ ì´ë²¤íŠ¸ ì²˜ë¦¬
        // ===========================================
        function onSelect(event) {
            if (!modelPlaced && reticle.visible) {
                // ëª¨ë¸ì´ ì•„ì§ ë°°ì¹˜ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë°°ì¹˜
                const reticlePosition = new THREE.Vector3();
                reticle.getWorldPosition(reticlePosition);
                
                ceraModel.position.copy(reticlePosition);
                scene.add(ceraModel);
                
                modelPlaced = true;
                reticle.visible = false;
                
                console.log('CERA ëª¨ë¸ì´ ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } else if (modelPlaced) {
                // ëª¨ë¸ì´ ì´ë¯¸ ë°°ì¹˜ë˜ì—ˆë‹¤ë©´ ì• ë‹ˆë©”ì´ì…˜ ì œì–´
                playAnimation();
            }
        }

        // ===========================================
        // ğŸ¨ XR ë Œë”ë§ ë£¨í”„
        // ===========================================
        function onXRFrame(time, frame) {
            xrSession.requestAnimationFrame(onXRFrame);

            const referenceSpace = xrReferenceSpace;
            const pose = frame.getViewerPose(referenceSpace);

            if (pose) {
                const view = pose.views[0];
                const viewport = xrSession.renderState.baseLayer.getViewport(view);
                
                renderer.setSize(viewport.width, viewport.height);

                // ì¹´ë©”ë¼ ë§¤íŠ¸ë¦­ìŠ¤ ì—…ë°ì´íŠ¸
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.updateMatrixWorld(true);

                // Hit-test ê²°ê³¼ ì²˜ë¦¬ (ëª¨ë¸ì´ ì•„ì§ ë°°ì¹˜ë˜ì§€ ì•Šì•˜ì„ ë•Œë§Œ)
                if (xrHitTestSource && !modelPlaced) {
                    const hitTestResults = frame.getHitTestResults(xrHitTestSource);
                    
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const hitPose = hit.getPose(referenceSpace);
                        
                        reticle.visible = true;
                        reticle.matrix.fromArray(hitPose.transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }

                // ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
                if (animationMixer) {
                    animationMixer.update(0.016); // ì•½ 60fps
                }

                // WebXR í”„ë ˆì„ë²„í¼ì— ë°”ì¸ë”©
                const glLayer = xrSession.renderState.baseLayer;
                renderer.getContext().bindFramebuffer(renderer.getContext().FRAMEBUFFER, glLayer.framebuffer);

                // ì”¬ ë Œë”ë§
                renderer.render(scene, camera);
            }
        }

        // ===========================================
        // ğŸ› ï¸ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        // ===========================================
        
        // ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬
        function checkCompatibility() {
            if (!navigator.xr) {
                document.querySelector('.ar-button').disabled = true;
                document.querySelector('.ar-button').textContent = 'WebXR ë¯¸ì§€ì›';
                document.querySelector('.info').innerHTML = '<p style="color: #ff6b6b;">âŒ ì´ ë¸Œë¼ìš°ì €ëŠ” WebXRì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</p>';
                return false;
            }
            return true;
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ í˜¸í™˜ì„± ì²´í¬ (ê°œì„ ëœ ë²„ì „)
        window.addEventListener('load', async () => {
            updateDebug('í˜ì´ì§€ ë¡œë”© ì™„ë£Œ, í˜¸í™˜ì„± í™•ì¸ ì¤‘...');
            await checkCompatibility();
        });

        // ì„¸ì…˜ ì¢…ë£Œ ì²˜ë¦¬
        function endXRSession() {
            if (xrSession) {
                xrSession.end();
                xrSession = null;
                
                // UI ë¦¬ì…‹
                document.querySelector('.container').style.display = 'block';
                document.getElementById('arControls').style.display = 'none';
                
                // ë³€ìˆ˜ ì´ˆê¸°í™”
                modelPlaced = false;
                currentState = animationStates.CHAIR_MODE;
                
                // Canvas ì œê±°
                const canvas = document.querySelector('canvas');
                if (canvas) {
                    canvas.remove();
                }
                
                console.log('AR ì„¸ì…˜ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        }

        // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ì„¸ì…˜ ì •ë¦¬
        window.addEventListener('beforeunload', endXRSession);
        
    </script>
</body>
</html>